#version 120
// standard normal diretional light one terxture pixel shader

uniform sampler2D texture;

varying vec3 normal;
varying vec3 position;

vec3 CalculateDirectionalLight()
{
	vec3 norm = normalize (normal);
	vec3 lighDir = normalize (gl_LightSource[0].position.xyz);
	vec3 specularDir = normalize (-position);
	vec3 refectionDir = reflect (lighDir, normal);

	vec3 diffuseCoeff = vec3(gl_LightSource[0].diffuse * gl_FrontMaterial.diffuse); 
	vec3 specularCoeff = vec3(gl_LightSource[0].specular * gl_FrontMaterial.specular);

	vec3 ambientColor = vec3(gl_LightSource[0].ambient * gl_FrontMaterial.ambient + gl_FrontMaterial.emission); 
	vec3 specularColor = specularCoeff * pow (max (dot (refectionDir, specularDir), 0.0), gl_FrontMaterial.shininess);


	//return vec3 (0.0, 0.0, 0.0);
	return ambientColor;
	//return specularColor;
	//return diffuseCoeff * max (dot(norm, lighDir), 0.0);
	//return diffuseCoeff * max (dot(norm, lighDir), 0.0) + ambientColor;
	//return diffuseCoeff * max (dot(norm, lighDir), 0.0) + ambientColor + specularColor;
}

vec3 CalculatePositionalLight(int index)
{
	vec3 norm = normalize (normal);
	vec3 lighDir = normalize (gl_LightSource[index].position.xyz);
	vec3 specularDir = normalize (-position);
	vec3 refectionDir = reflect (lighDir, normal);

	vec3 ambientColor = vec3(gl_LightSource[index].ambient * gl_FrontMaterial.ambient + gl_FrontMaterial.emission); 
	vec3 diffuseCoeff = vec3(gl_LightSource[index].diffuse * gl_FrontMaterial.diffuse); 
	vec3 specularCoeff = vec3(gl_LightSource[index].specular * gl_FrontMaterial.specular);
	vec3 specularColor = specularCoeff * pow (max (dot (refectionDir, specularDir), 0.0), gl_FrontMaterial.shininess);

	//return ambientColor;
	return specularColor;
	//return diffuseCoeff * max (dot(norm, lighDir), 0.0);
	//return diffuseCoeff * max (dot(norm, lighDir), 0.0) + ambientColor + specularColor;
}


void main()
{
	// get texture color
	vec3 texColor = vec3 (texture2D(texture, gl_TexCoord[0].st));

	//vec3 directionaLight = CalculateDirectionalLight() + CalculatePositionalLight(1);
	vec3 directionaLight = CalculateDirectionalLight();

	vec3 color = texColor * directionaLight;

	gl_FragColor = vec4 (color, 1.0);
}

